<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Hoarding Simulator</title>
    <script src="https://d3js.org/d3.v5.min.js"></script>
</head>
<body>
    <div>
        <button id="addHoarderBtn" onclick="addHoarders(this)">Add Hoarders</button>
        <button onclick="reset(this)">Restart</button>
    </div>
    <div>
        <svg width="1000" height="900">
            <image x="10" y="200" width="220" height="200" xlink:href="supermarket_optimized.svg" />
            <image id="truck" x="-100" y="230" width="100" height="200" xlink:href="icon_truck.svg" />
            <rect id="stock" width="50" height="300" fill="steelblue" x="250" y="60"/>
            <rect id="stockFrame" width="50" height="300" fill="none" stroke="black" x="250" y="60"/>
        </svg>
    </div>

    <script>

        let zoomFactor = 4
        let maxMarketStockHeight = 300
        let circleDistance = 60
        let customerOSX = 400

        let simulationInterval = 300
        let truckDuration = 1.5*simulationInterval

        let svg = d3.select("svg")
        svg.selectAll('#stockframe')
        .attr('height', maxMarketStockHeight)

        function render(customers, marketStock, marketStockLevel) {

            let marketStockHeight = maxMarketStockHeight * marketStock / marketStockLevel

            svg.selectAll('#stock')
            .attr('height', marketStockHeight)
            .attr('y', 60 + maxMarketStockHeight - marketStockHeight)

            let numEnded = 0;
            svg.selectAll('.buyTransition')
            .data(customers)
            .enter()
            .append('circle')
            .attr('class', 'buyTransition')
            .attr('fill', 'steelblue')
            svg.selectAll('.buyTransition')
            .attr('cy', 200 + 200*0.7) // center on supermarket logo
            .attr('cx', 10 + 220/2)
            .attr("r", customer => zoomFactor*Math.sqrt(customer.lastBuy))
            .transition()
            .attr("cy", customer => 60 + Math.floor(customer.id/10) * circleDistance)
            .attr("cx", customer => (customer.id%10) * circleDistance + customerOSX)
            .duration(simulationInterval*.8)
            .on("end",function() {
                numEnded++;
                if (numEnded === customers.length) {
                    svg.selectAll('.buyTransition')
                    .attr("r", 0)
                    renderCustomers(customers)
                }
            })
        }

        function renderCustomers(customers) {
            let stock = customers.map((c) => c.stock)

            let circlesStock = svg.selectAll(".stock")
            circlesStock.data(stock)
            .enter().append("circle")
            .attr('class', 'stock')
            .attr("cy", (d, i) => 60 + Math.floor(i/10) * circleDistance)
            .attr("cx", function(d, i) { return (i%10) * circleDistance + customerOSX })
            circlesStock
            .attr("r", d => zoomFactor*Math.sqrt(d))
            .attr('fill', 'steelblue')

            let circlesRefStock = svg.selectAll(".refstock")
            circlesRefStock.data(customers)
            .enter().append("circle")
            .attr('class', 'refstock')
            .attr("cy", (d, i) => 60 + Math.floor(i/10) * circleDistance)
            .attr("cx", function(d, i) { return (i%10) * circleDistance + customerOSX })
            .attr('fill', 'none')
            .attr('stroke', 'black')
            .attr('stroke-width', '1.5')
            circlesRefStock
            .attr("r", d => zoomFactor*Math.sqrt(d.stockLevel))
            .attr('stroke', d => d.understocked ? 'red' : 'black')
        }

        function animateTruck() {
            svg.selectAll("#truck")
            .transition()
            .attr('x', 100)
            .duration(truckDuration)
            .on("end",function() {
                svg.selectAll("#truck")
                .transition()
                .attr('x', -100)
                .duration(truckDuration)
            })


        }

        // configuration
        let config = {
            customers: 100,
            consumptionInterval: 24, // per 24 ticks
            deliveryInterval: 24,
            defaultPrivateStock: 5,
            adaptedPrivateStock: 30,
            reserve: 8,
            stockSizeDays: 2
        }

        config.stockLevel = config.stockSizeDays * config.customers * config.deliveryInterval / config.consumptionInterval
        console.log(`stocklevel ${config.stockLevel}`)

        let updateOrder = []
        for (let i = 0; i < config.customers; i++) {
            updateOrder.push(i);
        }

        let clock
        let stock
        let timeSinceLastDelivery
        let customers

        function reset() {
            document.getElementById('addHoarderBtn').removeAttribute('disabled')
            stock = config.stockLevel
            clock = 0
            timeSinceLastDelivery = 15
            customers = []
            for (let i = 0; i < config.customers; i++) {
                customers.push({
                    id: i,
                    stock: config.defaultPrivateStock + Math.floor(Math.random() * 10),
                    stockLevel: config.defaultPrivateStock,
                    timeSinceLastConsumption: Math.floor(Math.random() * 24),
                    lastBuy: 0,
                    understocked: false
                })
            }
        }

        function shuffle(array) {
            let currentIndex = array.length, temporaryValue, randomIndex

            // While there remain elements to shuffle...
            while (0 !== currentIndex) {

                // Pick a remaining element...
                randomIndex = Math.floor(Math.random() * currentIndex)
                currentIndex -= 1

                // And swap it with the current element.
                temporaryValue = array[currentIndex]
                array[currentIndex] = array[randomIndex]
                array[randomIndex] = temporaryValue
            }

            return array
        }

        function updateCustomer(customer) {
            customer.timeSinceLastConsumption += 1
            if (customer.timeSinceLastConsumption >= config.consumptionInterval && customer.stock > 0) {
                customer.stock -= 1
                customer.timeSinceLastConsumption = 0
            }
            if (customer.stock < customer.stockLevel) {
                let buyQuantity = customer.stockLevel - customer.stock + config.reserve
                let amount = Math.min(buyQuantity, stock)
                customer.stock += amount
                stock -= amount
                customer.lastBuy = amount
                if (amount === 0) {
                    customer.stockLevel = config.adaptedPrivateStock
                }
                customer.understocked = customer.stock < customer.stockLevel
            } else {
                customer.lastBuy = 0
            }
        }

        function simulationStep() {
            clock += 1
            timeSinceLastDelivery += 1

            if (timeSinceLastDelivery === 24) {
                console.log('delivery')
                animateTruck()
                setTimeout(() => {
                    stock = config.stockLevel
                    timeSinceLastDelivery = 0
                    render(customers, stock, config.stockLevel)
                },truckDuration)
            } else {
                shuffle(updateOrder)
                for (let i of updateOrder) {
                    updateCustomer(customers[i])
                }

                let numHoarders = 0
                for (let customer of customers) {
                    if (customer.stockLevel === config.adaptedPrivateStock) {
                        numHoarders += 1
                    }
                }
                console.log(`clock: ${clock}: stock ${stock} hoarders ${numHoarders}`)
            }


            render(customers, stock, config.stockLevel)
        }

        function addHoarders(button) {
            shuffle(updateOrder)
            for (let i of updateOrder.slice(0, 10)) {
                customers[i].stockLevel = config.adaptedPrivateStock
            }
            button.setAttribute('disabled', 'true')
        }

        reset()
        renderCustomers(customers)
        setInterval(simulationStep, simulationInterval)
    </script>


</body>
</html>