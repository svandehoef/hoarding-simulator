<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Hoarding Simulator</title>
    <script src="https://d3js.org/d3.v5.min.js"></script>
</head>
<body>
    <svg width="900" height="900">
        <rect id="stock" width="50" height="300" fill="steelblue" x="60" y="60"/>
        <rect id="stockFrame" width="50" height="300" fill="none" stroke="black" x="60" y="60"/>
    </svg>
    <div>
        <label>Stock:</label>
        <input type="range" min="0" max="40" value="10" class="slider" id="myRange">
    </div>

    <script>

        let zoomFactor = 4
        let maxMarketStockHeight = 300
        let circleDistance = 60
        let customerOSX = 200

        let simulationInterval = 300

        let svg = d3.select("svg")
        svg.selectAll('#stockframe')
        .attr('height', maxMarketStockHeight)

        let slider = document.getElementById("myRange")

        // Update the current slider value (each time you drag the slider handle)
        slider.oninput = function() {
            console.log(this.value)
        }

        function render(customers, marketStock, marketStockLevel) {

            let marketStockHeight = maxMarketStockHeight * marketStock / marketStockLevel

            svg.selectAll('#stock')
            .attr('height', marketStockHeight)
            .attr('y', 60 + maxMarketStockHeight - marketStockHeight)

            let numEnded = 0;
            svg.selectAll('.buyTransition')
            .data(customers)
            .enter()
            .append('circle')
            .attr('class', 'buyTransition')
            .attr('cy', 30 + maxMarketStockHeight/2)
            .attr('cx', 85)
            .attr('fill', 'steelblue')
            svg.selectAll('.buyTransition')
            .attr('cy', 30 + maxMarketStockHeight/2)
            .attr('cx', 55)
            .attr("r", customer => zoomFactor*Math.sqrt(customer.lastBuy))
            .transition()
            .attr("cy", customer => 60 + Math.floor(customer.id/10) * circleDistance)
            .attr("cx", customer => (customer.id%10) * circleDistance + customerOSX)
            .duration(simulationInterval*.8)
            .on("end",function() {
                numEnded++;
                if (numEnded === customers.length) {
                    svg.selectAll('.buyTransition')
                    .attr("r", 0)
                    renderCustomers(customers)
                }
            })
        }

        function renderCustomers(customers) {
            let stock = customers.map((c) => c.stock)

            let circlesStock = svg.selectAll(".stock")
            circlesStock.data(stock)
            .enter().append("circle")
            .attr('class', 'stock')
            .attr("cy", (d, i) => 60 + Math.floor(i/10) * circleDistance)
            .attr("cx", function(d, i) { return (i%10) * circleDistance + customerOSX })
            circlesStock
            .attr("r", d => zoomFactor*Math.sqrt(d))
            .attr('fill', 'steelblue')

            let circlesRefStock = svg.selectAll(".refstock")
            circlesRefStock.data(customers)
            .enter().append("circle")
            .attr('class', 'refstock')
            .attr("cy", (d, i) => 60 + Math.floor(i/10) * circleDistance)
            .attr("cx", function(d, i) { return (i%10) * circleDistance + customerOSX })
            .attr('fill', 'none')
            .attr('stroke', 'black')
            .attr('stroke-width', '1.5')
            circlesRefStock
            .attr("r", d => zoomFactor*Math.sqrt(d.stockLevel))
            .attr('stroke', d => d.understocked ? 'red' : 'black')

        }

    </script>

    <script>
        // configuration
        let config = {
            customers: 100,
            consumptionInterval: 24, // per 24 ticks
            deliveryInterval: 24,
            defaultPrivateStock: 5,
            adaptedPrivateStock: 30,
            reserve: 8,
            stockSizeDays: 2
        }

        config.stockLevel = config.stockSizeDays * config.customers * config.deliveryInterval / config.consumptionInterval
        console.log(`stocklevel ${config.stockLevel}`)


        let clock = 0

        let updateOrder = []
        for (let i = 0; i < config.customers; i++) {
            updateOrder.push(i);
        }

        let stock = config.stockLevel
        let timeSinceLastDelivery = 0
        let customers = []
        for (let i = 0; i < config.customers; i++) {
            customers.push({
                id: i,
                stock: config.defaultPrivateStock + Math.floor(Math.random() * 10),
                stockLevel: config.defaultPrivateStock,
                timeSinceLastConsumption: Math.floor(Math.random() * 24),
                lastBuy: 0,
                understocked: false
            })
        }
        renderCustomers(customers)

        function shuffle(array) {
            let currentIndex = array.length, temporaryValue, randomIndex

            // While there remain elements to shuffle...
            while (0 !== currentIndex) {

                // Pick a remaining element...
                randomIndex = Math.floor(Math.random() * currentIndex)
                currentIndex -= 1

                // And swap it with the current element.
                temporaryValue = array[currentIndex]
                array[currentIndex] = array[randomIndex]
                array[randomIndex] = temporaryValue
            }

            return array
        }

        function updateCustomer(customer) {
            customer.timeSinceLastConsumption += 1
            if (customer.timeSinceLastConsumption >= config.consumptionInterval && customer.stock > 0) {
                customer.stock -= 1
                customer.timeSinceLastConsumption = 0
            }
            if (customer.stock < customer.stockLevel) {
                let buyQuantity = customer.stockLevel - customer.stock + config.reserve
                let amount = Math.min(buyQuantity, stock)
                customer.stock += amount
                stock -= amount
                customer.lastBuy = amount
                if (amount === 0) {
                    customer.stockLevel = config.adaptedPrivateStock
                }
                customer.understocked = customer.stock < customer.stockLevel
            } else {
                customer.lastBuy = 0
            }
        }

        function simulationStep() {
            clock += 1
            timeSinceLastDelivery += 1
            if (timeSinceLastDelivery === 24) {
                console.log('delivery')
                stock = config.stockLevel
                timeSinceLastDelivery = 0
            } else {
                shuffle(updateOrder)
                for (let i of updateOrder) {
                    updateCustomer(customers[i])
                }
                if (clock === 100) {
                    stock = 0
                }
                let numHoarders = 0
                for (let customer of customers) {
                    if (customer.stockLevel === config.adaptedPrivateStock) {
                        numHoarders += 1
                    }
                }
                console.log(`clock: ${clock}: stock ${stock} hoarders ${numHoarders}`)
            }


            render(customers, stock, config.stockLevel)
        }

        setInterval(simulationStep, simulationInterval)
    </script>


</body>
</html>